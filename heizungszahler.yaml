esphome:
  name: heizungszaehler
  friendly_name: Heizungszähler
  project:
    name: custom.heizungszaehler
    version: 1.0.1
  platformio_options:
    board_build.flash_mode: qio
  on_boot:
    priority: 400
    then:
      - light.turn_on:
          id: status_led
          brightness: 25%
          red: 0%
          green: 0%
          blue: 100%

esp32:
  board: esp32-c6-devkitm-1
  variant: esp32c6
  flash_size: 4MB
  framework:
    type: esp-idf

# Enable logging
logger:
  level: DEBUG

# Enable Home Assistant API
api:
  encryption:
    key: !secret ha_api_key_heat

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  use_address: heizungszaehler.fritz.box

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "${friendly_name} Fallback"
    password: !secret fallback_hs_password

  on_connect:
    then:
      - light.turn_on:
          id: status_led
          brightness: 25%
          red: 0%
          green: 100%
          blue: 0%

  on_disconnect:
    then:
      - light.turn_on:
          id: status_led
          brightness: 25%
          red: 100%
          green: 0%
          blue: 0%

captive_portal:

web_server:
  local: True

preferences:
  flash_write_interval: 1min

light:
  - platform: esp32_rmt_led_strip
    id: status_led
    name: "RGB LED"
    num_leds: 1
    pin: GPIO8
    chipset: ws2812
    rgb_order: RGB
    internal: true
    default_transition_length: 0.5s

# Persistente Zähler / Zustände
globals:
  # Gesamtverbrauch Heizöl als Mikroliter (1 L = 1_000_000 µL)
  - id: oil_total_ul
    type: int64_t
    restore_value: yes
    initial_value: '0'

  # Gesamt-Brennerlaufzeit in Millisekunden
  - id: burner_total_on_ms
    type: int64_t
    restore_value: yes
    initial_value: '0'

  # Laufender Zustand (nicht persistent; wird bei Neustart als AUS angenommen)
  - id: burner_is_on
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: burner_on_start_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'

  - id: burner_last_transition_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'

  - id: burner_last_integrate_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'

script:
  - id: burner_turn_on
    mode: restart
    then:
      - lambda: |-
          const uint32_t now = millis();
          const uint32_t min_off_ms = (uint32_t) (id(burner_min_off_s).state * 1000.0f);

          if (id(burner_is_on)) {
            return;
          }

          if (id(burner_last_transition_ms) > 0 && min_off_ms > 0 && (uint32_t)(now - id(burner_last_transition_ms)) < min_off_ms) {
            ESP_LOGD("oil_meter", "Ignoriere Einschalten (min. Pause noch nicht erreicht)");
            return;
          }

          id(burner_is_on) = true;
          id(burner_on_start_ms) = now;
          id(burner_last_integrate_ms) = now;
          id(burner_last_transition_ms) = now;

          // Momentanwerte setzen
          id(oil_flow_lph).publish_state(id(burner_liters_per_hour).state);
          id(heat_power_kw).publish_state(id(burner_liters_per_hour).state * id(heat_kwh_per_liter).state);

  - id: burner_turn_off
    mode: restart
    then:
      - lambda: |-
          const uint32_t now = millis();
          const uint32_t min_on_ms = (uint32_t) (id(burner_min_on_s).state * 1000.0f);

          if (!id(burner_is_on)) {
            return;
          }

          const uint32_t on_time = (uint32_t)(now - id(burner_on_start_ms));
          if (id(burner_on_start_ms) > 0 && min_on_ms > 0 && on_time < min_on_ms) {
            ESP_LOGD("oil_meter", "Ignoriere Ausschalten (min. Laufzeit noch nicht erreicht)");
            return;
          }

          // Letztes Stück integrieren
          if (id(burner_last_integrate_ms) > 0) {
            const uint32_t delta_ms = (uint32_t)(now - id(burner_last_integrate_ms));
            if (delta_ms > 0) {
              const float lph = id(burner_liters_per_hour).state;
              const float add_ul_f = (lph * (float)delta_ms * 1000000.0f) / 3600000.0f;
              const int64_t add_ul = (int64_t) (add_ul_f + 0.5f);
              id(oil_total_ul) += add_ul;
              id(burner_total_on_ms) += delta_ms;
            }
          }

          id(burner_is_on) = false;
          id(burner_last_integrate_ms) = 0;
          id(burner_last_transition_ms) = now;

          // Momentanwerte zurücksetzen
          id(oil_flow_lph).publish_state(0.0f);
          id(heat_power_kw).publish_state(0.0f);

interval:
  - interval: 5s
    then:
      - lambda: |-
          // Während Brenner an ist: Ölverbrauch kontinuierlich über Laufzeit integrieren
          if (!id(burner_is_on)) {
            return;
          }

          const uint32_t now = millis();
          if (id(burner_last_integrate_ms) == 0) {
            id(burner_last_integrate_ms) = now;
            return;
          }

          const uint32_t delta_ms = (uint32_t)(now - id(burner_last_integrate_ms));
          if (delta_ms == 0) {
            return;
          }

          id(burner_last_integrate_ms) = now;
          id(burner_total_on_ms) += delta_ms;

          const float lph = id(burner_liters_per_hour).state;
          const float add_ul_f = (lph * (float)delta_ms * 1000000.0f) / 3600000.0f;
          const int64_t add_ul = (int64_t) (add_ul_f + 0.5f);
          id(oil_total_ul) += add_ul;

          // Abgeleitete Werte publishen
          const float oil_l = (float)id(oil_total_ul) / 1000000.0f;
          const float kwh = oil_l * id(heat_kwh_per_liter).state;
          id(oil_used_l).publish_state(oil_l);
          id(heat_energy_kwh).publish_state(kwh);
          id(burner_runtime_h).publish_state(((float)id(burner_total_on_ms)) / 3600000.0f);

binary_sensor:
  - platform: status
    name: Status

  - platform: template
    name: "Brenner aktiv"
    id: burner_active
    device_class: running
    entity_category: diagnostic
    lambda: |-
      float threshold = id(mic_threshold_v).state;
      if (threshold <= 0.0f) threshold = 0.05f;
      return id(mic_envelope).state > threshold;
    filters:
      - delayed_on: 2s
      - delayed_off: 5s
    on_press:
      then:
        - script.execute: burner_turn_on
    on_release:
      then:
        - script.execute: burner_turn_off

sensor:
  # Mikrofon/Audio am ADC: wir nutzen eine einfache Hüllkurve (|V - Center|) + EMA.
  # Hinweis: Falls GPIO0 auf deinem ESP32-C6 kein ADC-Pin ist, hier auf einen ADC-fähigen Pin wechseln.
  - platform: adc
    pin: GPIO0
    id: mic_adc
    internal: true
    raw: false
    attenuation: 12db
    update_interval: 5ms
    samples: 40
    accuracy_decimals: 4
    unit_of_measurement: "V"

  - platform: template
    name: "Mikrofon ADC (Diag)"
    id: mic_adc_exposed
    unit_of_measurement: "V"
    accuracy_decimals: 4
    update_interval: 1s
    entity_category: diagnostic
    lambda: 'return id(mic_adc).state;'

  - platform: template
    name: "Mikrofon Hüllkurve"
    id: mic_envelope
    internal: true
    unit_of_measurement: "V"
    accuracy_decimals: 4
    update_interval: 20ms
    lambda: |-
      const float center = id(mic_center_v).state;
      float v = id(mic_adc).state;
      return fabsf(v - center);
    filters:
      - exponential_moving_average:
          alpha: 0.10

  - platform: template
    name: "Mikrofon Hüllkurve (Diag)"
    id: mic_envelope_exposed
    unit_of_measurement: "V"
    accuracy_decimals: 4
    update_interval: 1s
    entity_category: diagnostic
    lambda: 'return id(mic_envelope).state;'

  - platform: template
    name: "Ölverbrauch"
    id: oil_used_l
    icon: mdi:oil
    unit_of_measurement: "L"
    accuracy_decimals: 3
    state_class: total_increasing
    lambda: 'return (float) id(oil_total_ul) / 1000000.0f;'

  - platform: template
    name: "Heizenergie"
    id: heat_energy_kwh
    icon: mdi:fire
    unit_of_measurement: "kWh"
    accuracy_decimals: 2
    state_class: total_increasing
    device_class: energy
    lambda: |-
      float oil_l = (float) id(oil_total_ul) / 1000000.0f;
      return oil_l * id(heat_kwh_per_liter).state;

  - platform: template
    name: "Ölfluss"
    id: oil_flow_lph
    unit_of_measurement: "L/h"
    accuracy_decimals: 2
    state_class: measurement
    lambda: 'return id(burner_is_on) ? id(burner_liters_per_hour).state : 0.0f;'

  - platform: template
    name: "Heizleistung"
    id: heat_power_kw
    unit_of_measurement: "kW"
    accuracy_decimals: 1
    state_class: measurement
    lambda: 'return id(burner_is_on) ? (id(burner_liters_per_hour).state * id(heat_kwh_per_liter).state) : 0.0f;'

  - platform: template
    name: "Brenner Laufzeit"
    id: burner_runtime_h
    unit_of_measurement: "h"
    accuracy_decimals: 2
    entity_category: diagnostic
    lambda: 'return ((float) id(burner_total_on_ms)) / 3600000.0f;'

  - platform: template
    name: "Ölverbrauch (intern µL)"
    id: oil_total_ul_sensor
    unit_of_measurement: "uL"
    accuracy_decimals: 0
    entity_category: diagnostic
    lambda: 'return (float) id(oil_total_ul);'

  - platform: wifi_signal
    name: WiFi Signal
    update_interval: 30s
    entity_category: diagnostic
    filters:
      - throttle: 10min

text_sensor:
  - platform: wifi_info
    ip_address:
      name: IP Adresse

number:
  # Optional: Stand aus Home Assistant (Liter) importieren
  - platform: homeassistant
    id: last_oil_value
    entity_id: input_number.heizungszaehler_letzter_wert
    on_value:
      then:
        - lambda: |-
            // x: Liter
            if (x >= 0) {
              const float ha_ul_f = x * 1000000.0f;
              const int64_t ha_ul = (int64_t) (ha_ul_f + 0.5f);
              if (ha_ul > id(oil_total_ul)) {
                id(oil_total_ul) = ha_ul;
              }
              id(oil_used_l).publish_state((float)id(oil_total_ul) / 1000000.0f);
              id(heat_energy_kwh).publish_state(((float)id(oil_total_ul) / 1000000.0f) * id(heat_kwh_per_liter).state);
              id(oil_total_ul_sensor).publish_state((float)id(oil_total_ul));
            }

  - platform: template
    id: burner_liters_per_hour
    name: Brennerverbrauch
    icon: mdi:oil
    unit_of_measurement: "L/h"
    entity_category: config
    min_value: 0
    max_value: 10
    step: 0.01
    initial_value: 2.00
    optimistic: true
    restore_value: true

  - platform: template
    id: heat_kwh_per_liter
    name: Heizwert
    icon: mdi:fire
    unit_of_measurement: "kWh/L"
    entity_category: config
    min_value: 0
    max_value: 15
    step: 0.01
    initial_value: 10.00
    optimistic: true
    restore_value: true

  - platform: template
    id: mic_center_v
    name: Mikrofon Center
    icon: mdi:microphone
    unit_of_measurement: "V"
    entity_category: config
    min_value: 0
    max_value: 3.3
    step: 0.001
    initial_value: 1.65
    optimistic: true
    restore_value: true

  - platform: template
    id: mic_threshold_v
    name: Brenner-Schwelle
    icon: mdi:tune
    unit_of_measurement: "V"
    entity_category: config
    min_value: 0
    max_value: 1.0
    step: 0.001
    initial_value: 0.05
    optimistic: true
    restore_value: true

  - platform: template
    id: burner_min_on_s
    name: Mindestlaufzeit
    icon: mdi:timer
    unit_of_measurement: "s"
    entity_category: config
    min_value: 0
    max_value: 600
    step: 1
    initial_value: 10
    optimistic: true
    restore_value: true

  - platform: template
    id: burner_min_off_s
    name: Mindestpause
    icon: mdi:timer
    unit_of_measurement: "s"
    entity_category: config
    min_value: 0
    max_value: 600
    step: 1
    initial_value: 10
    optimistic: true
    restore_value: true

  - platform: template
    id: target_oil_value
    name: Manueller Ölstand
    icon: mdi:counter
    unit_of_measurement: "L"
    entity_category: config
    mode: box
    optimistic: true
    min_value: 0
    max_value: 9999999
    step: 0.1

button:
  - platform: template
    name: Ölstand überschreiben
    icon: mdi:download
    entity_category: config
    on_press:
      - lambda: |-
          float v = id(target_oil_value).state;
          if (v >= 0) {
            const float v_ul_f = v * 1000000.0f;
            id(oil_total_ul) = (int64_t) (v_ul_f + 0.5f);
            id(burner_total_on_ms) = 0;
            id(burner_is_on) = false;
            id(burner_last_integrate_ms) = 0;
            id(burner_last_transition_ms) = 0;
            id(burner_on_start_ms) = 0;
            id(oil_used_l).publish_state((float)id(oil_total_ul) / 1000000.0f);
            id(heat_energy_kwh).publish_state(((float)id(oil_total_ul) / 1000000.0f) * id(heat_kwh_per_liter).state);
            id(oil_total_ul_sensor).publish_state((float)id(oil_total_ul));
            id(target_oil_value).publish_state(0.0);
          }
